{"id":"../node_modules/ecc-jsbn/index.js","dependencies":[{"name":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/package.json","includedInParent":true,"mtime":1582912700200},{"name":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/node_modules/ecc-jsbn/package.json","includedInParent":true,"mtime":1582905740334},{"name":"crypto","loc":{"line":1,"column":21},"parent":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/node_modules/ecc-jsbn/index.js","resolved":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/node_modules/crypto-browserify/index.js"},{"name":"jsbn","loc":{"line":2,"column":25},"parent":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/node_modules/ecc-jsbn/index.js","resolved":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/node_modules/jsbn/index.js"},{"name":"./lib/ec.js","loc":{"line":3,"column":24},"parent":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/node_modules/ecc-jsbn/index.js","resolved":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/node_modules/ecc-jsbn/lib/ec.js"},{"name":"safer-buffer","loc":{"line":4,"column":21},"parent":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/node_modules/ecc-jsbn/index.js","resolved":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/node_modules/safer-buffer/safer.js"},{"name":"./lib/sec.js","loc":{"line":5,"column":27},"parent":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/node_modules/ecc-jsbn/index.js","resolved":"/Users/calumryan/Sites/kirbystarter/site/plugins/weather/node_modules/ecc-jsbn/lib/sec.js"}],"generated":{"js":"\nvar crypto = require(\"crypto\");\nvar BigInteger = require(\"jsbn\").BigInteger;\nvar ECPointFp = require(\"./lib/ec.js\").ECPointFp;\nvar Buffer = require(\"safer-buffer\").Buffer;\nexports.ECCurves = require(\"./lib/sec.js\");\n\n// zero prepad\nfunction unstupid(hex,len)\n{\n\treturn (hex.length >= len) ? hex : unstupid(\"0\"+hex,len);\n}\n\nexports.ECKey = function(curve, key, isPublic)\n{\n  var priv;\n\tvar c = curve();\n\tvar n = c.getN();\n  var bytes = Math.floor(n.bitLength()/8);\n\n  if(key)\n  {\n    if(isPublic)\n    {\n      var curve = c.getCurve();\n//      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format\n//      var y = key.slice(bytes+1);\n//      this.P = new ECPointFp(curve,\n//        curve.fromBigInteger(new BigInteger(x.toString(\"hex\"), 16)),\n//        curve.fromBigInteger(new BigInteger(y.toString(\"hex\"), 16)));      \n      this.P = curve.decodePointHex(key.toString(\"hex\"));\n    }else{\n      if(key.length != bytes) return false;\n      priv = new BigInteger(key.toString(\"hex\"), 16);      \n    }\n  }else{\n    var n1 = n.subtract(BigInteger.ONE);\n    var r = new BigInteger(crypto.randomBytes(n.bitLength()));\n    priv = r.mod(n1).add(BigInteger.ONE);\n    this.P = c.getG().multiply(priv);\n  }\n  if(this.P)\n  {\n//  var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);\n//  this.PublicKey = Buffer.from(\"04\"+pubhex,\"hex\");\n    this.PublicKey = Buffer.from(c.getCurve().encodeCompressedPointHex(this.P),\"hex\");\n  }\n  if(priv)\n  {\n    this.PrivateKey = Buffer.from(unstupid(priv.toString(16),bytes*2),\"hex\");\n    this.deriveSharedSecret = function(key)\n    {\n      if(!key || !key.P) return false;\n      var S = key.P.multiply(priv);\n      return Buffer.from(unstupid(S.getX().toBigInteger().toString(16),bytes*2),\"hex\");\n   }     \n  }\n}\n\n"},"sourceMaps":null,"error":null,"hash":"9f52425b9a75a6bd88dedcfb01576cbe","cacheData":{"env":{}}}